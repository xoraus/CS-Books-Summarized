- Chapter 07: Highlights
    - The subclasses inherit the methods of the superclass. In other words, if the Shape class has the functionality, then the subclasses automatically get that same functionality.
    - Overriding just means that a subclass redefines one of its inherited methods when it needs to change or extend the behavior of that method.
    - In Java, we say that the subclass extends the superclass. An inheritance relationship means that the subclass inherits the members of the superclass.
    - Instance variables are not overridden because they don’t define any special behavior, so a subclass can give an inherited instance variable any value it chooses.
    - Let's design the inheritance tree
        - Look for objects that have common attributes and behaviors.
        - Design a class that represents the common state and behavior.
        - Decide if a subclass needs behaviors (method implementations) that are specific to that particular subclass type.
        - Look for more opportunities to use abstraction, by finding two or more subclasses that might need common behavior.
        - Finish the class hierarchy
    - Q: How does the JVM handle method invocation when it can't find a match in the inheritance tree?
        - A: The JVM starts by traversing the inheritance tree, but if it doesn't find a matching method, you don't need to worry. The compiler ensures that a method is callable for a specific reference type without concern for its actual runtime origin. In the case of inheritance, the method's definition location (superclass) doesn't matter to the compiler. However, at runtime, the JVM always selects the most specific version of the method for the particular object being used.
    - Remember that when one class inherits from another, we say that the subclass extends the superclass. When you want to know if one thing should extend another, apply the IS-A test.
    - For now, though, a good guideline is to use the IS-A test. If "XIS-AY"' makes sense, both classes (X and Y) should probably live in the same inheritance hierarchy. Chances are, they have the same or overlapping behaviors.
    - Keep in mind that the inheritance IS- relationship works in only one direction!
    - Q: Can a superclass use the subclass version of a method, and how does this work?
        - A: No, a superclass won't necessarily be aware of its subclasses, and there's no concept of "reverse" or backward inheritance. Inheritance flows from parent to child, not the other way around.
    - Q: How can I use both the superclass and subclass versions of a method in a subclass without completely replacing the superclass version?
        - A: You can achieve this by extending the functionality of the superclass. Use the "extends" keyword to inherit the superclass method, and then add your own code. In your subclass, you can call the superclass version using the "super" keyword. This allows you to first execute the superclass version and then supplement it with your own code.
    - A superclass can choose whether or not it wants a subclass to inherit a particular member by the level of access the particular member is given.
    - Access levels control who sees what, and are crucial to having well-designed, robust Java code. 
    - When designing with inheritance:
        - DO:  
            - 1. Use inheritance when one class is a more specific type of a superclass. Example: Willow is a specific type of Tree, so Willow extends Tree is appropriate.
            - 2. Consider inheritance when you have shared behavior among multiple classes of the same type. Example: Using a superclass like Shape for Square, Circle, and Triangle to share common functionality can enhance maintenance and extensibility.
        - DO NOT:  
            - 1. Use inheritance solely for code reuse if it violates the above rules. Example: Avoid making a class extend another class just to reuse code when the relationship doesn't fit.
            - 2. Use inheritance if the subclass and superclass fail the IS-A test. Example: Tea IS-A Beverage is valid, but Beverage IS-A Tea is not.
        - Inheritance is a fundamental aspect of object-oriented programming, but it's essential to use it appropriately and consider alternative design patterns for more flexible solutions when needed.
    - So what does all this inheritance really buy you?
        - You avoid duplicate code.
        - You define a common protocol for a group of classes.
    - A Java program is nothing but a pile of classes, so the subclasses don’t have to be recompiled in order to use the new version of the superclass. As long as the superclass doesn’t break anything for the subclass, everything’s fine.
    - With polymorphism, the reference type can be a superclass of the actual object type.
    - You can have polymorphic arguments and return types.
    - With polymorphism, you can write code that doesn't have to change when you introduce new subclass types into the program.
    - Q: Are there practical limits on subclassing depth in Java?
        - A: Most inheritance hierarchies in the Java API are wide but not deep, typically one or two levels deep. While it usually makes sense to keep inheritance trees shallow, there isn't a hard limit on how deep you can go.
    - Q: Can you use subclassing to modify a method when you don't have access to the source code?
        - A: Yes, you can extend a class to override its method with your own code, even if you don't have access to the source code. It's a useful feature that can save you from rewriting the entire class or finding the original programmer.
    - Q: Can you extend any class, or are there restrictions on subclassing?
        - A: You can't subclass a class with non-public access unless you're in the same package. A final class, indicated by the "final" keyword, cannot be extended. Additionally, a class with only private constructors cannot be subclassed.
    - Q: Why make a class final, and what's the advantage of preventing subclassing?
        - A: Final classes are rare but provide the security of unalterable methods, ensuring they work as designed. This is valuable for classes like those in the Java API, such as the String class. You can also mark specific methods as final to prevent them from being overridden without making the whole class final.
- Keeping the contract: rules for overriding
    - Arguments must be the same, and return types must be compatible.
    - The method can't be less accessible.
- An overloaded method is a just a different method that happens to have the same method name. It has nothing to do with inheritance and polymorphism. An overloaded method is NOT the same as an overridden method.
- Overloading a method
    - The return types can be different.
    - You can't change ONLY the return type.
    - You can vary the access levels in any direction.
- Chapter 07: Summary
    - A subclass extends a superclass.
    - A subclass inherits all public instance variables and methods of the superclass, but does not inherit the private instance variables and methods of the superclass.
    - Inherited methods can be overridden; instance variables cannot be overridden (although they can be redefined in the subclass, but that's not the same thing, and there's almost never a need to do it.)
    - Use the IS-A test to verify that your inheritance hierarchy is valid. If X extends Y. then X IS-A Y must make sense.
    - The IS-A relationship works in only one direction. A Hippo is an Animal, but not all Animals are Hippos. a When a method is overridden in a subclass, and that method is invoked on an instance of the subclass, the overridden version of the method is called. (The lowest one wins.)
    - If class B extends A, and C extends B, class B IS-A class A, and class C IS-A class B, and class C also IS-A class A.