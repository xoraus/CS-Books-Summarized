## Make a Connection: networking and threads

### Chapter 17: Summary
- Client and server applications communicate using Channels. A Channel represents a connection between two applications that may (or may not) be running on two different physical machines.
- A client must know the IP address (or host name) and TCP port number of the server application.
- A TCP port is a 16-bit unsigned number assigned to specific server application. TCP port numbers allow different server applications to run on the same machine; clients connect to a specific application using its port number.
- The port numbers from 0 through 1023 are reserved for "well-known services" including HTTP, FTP, SMTP, etc.
- A client connects to a server by opening a SocketChannel: 
    - SocketChannel.open(new InetSocketAddress("127.0.0.1", 4200))  
- Once connected, client can create readers (to read data from the server) and writers (to send data to the server) for the channel:
    - Reader reader = Channels.newReader(sockCh, StandardCharsets.UTF_8); 
    - Writer writer = Channels.newWriter(sockCh, StandardCharsets.UTF_8); 
- To read text data from the server, create a BufferedReader, chained to the Reader. The Reader is a "bridge" that takes in bytes and converts them to text (character) data. It's used primarily to act as the middle chain between the high-level BufferedReader and the low-level connection.
- To write text data to the server, create a PrintWriter chained to the Writer. Cal the print() or printIn() methods to send Strings to the server.
- Servers use a ServerSocketChannel that waits for client requests on a particular port number.
- When a ServerSocketChannel gets a request, "accepts" the request by making a SocketChannel for the client.
- A thread with a lowercase "t" is a separate thread of execution in Java.
- Every thread in Java has ts own call stack.
- A Thread with a capital "T" is the java.lang. Thread class. A Thread object represents a thread of execution.
- A thread needs a job to do. The job can be an instance of something that implements the Runnable interface.
- The Runnable interface has just a single method, run(). This is the method that goes on the bottom of the new call stack. In other words, it is the first method to run in the new thread. 
- Because the Runnable interface has just a single method, you can use lambda expressions where Runnable is expected. 
- Using the Thread class to run separate jobs is no longer the preferred way to create multithreaded applications in Java. Instead, use an Executor or an ExecutorService.
- The Executors class has helper methods that can create standard Executor Services to use to start new jobs.
- A thread is in the NEW state when it has not yet started.
- When a thread has been started, a new stack is created, with the Runnable's run() method on the bottom of the stack. The is thread is now in the RUNNABLE state, waiting to be chosen to run.
- A thread is said to be RUNNING when the JVM's thread scheduler has selected it to be the currently running thread. On a single-processor machine, there can be only one currently running thread.
- Sometimes a thread can be moved from the RUNNING state to a temporarily NON-RUNNABLE state. A thread might be blocked because it's waiting for data from a stream, because it has gone to sleep, or because it is waiting for an object's lock. We'll see locks in the next chapter.
- Thread scheduling is not guaranteed to work in any particular way, so you cannot be certain that threads will take turns nicely.
- The static Thread.sleep() method forces a to thread to leave the running state for at least the duration passed to the sleep method. Thread.sleep(200) puts a thread to sleep for 200 milliseconds.
- You can also use the sleep method on java.til. concurrent. Time Unit, for example TimeUnit.SECONDS.sleep(2).
- The sleep() method throws checked exception (InterruptedException), so all calls to sleep() must be wrapped in a try/ catch, or declared.
- There are different mechanisms to give threads a chance to wait for each other.
- You can use sleep(), but you can also use CountDownLatch to wait for the right number of events to have happened before continuing.
- Managing threads directly can be lot of work. Use the factory methods in Executors to create an Executor Service, and use this service to run Runnable jobs.
- Thread pools can manage creation, reuse, and destruction of threads so you don't have to.
- ExecutorServices should be shut down correctly so the jobs are finished and threads terminated. Use shutdown() for graceful shutdown, and shutdownNow() to kill everything.