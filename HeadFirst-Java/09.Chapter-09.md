## Life and Death of an Object: constructors and garbage collection 

### Chapter 09: Highlights
- two areas of memory- the Stack and the Heap.
- When a JVM starts up, it gets a chunk of memory from the underlying OS and uses it to run your Java program.
- Instance Variables - Instance variables are declared inside a class but not inside a method. They represent the "fields" that each individual object has (which can be filled with different values for each instance of the class). Instance variables live inside the object they belong to.
- Local Variables - Local variables are declared inside a method, including method parameters. They're temporary and live only as long as the method is on the stack (in other words, as long as the method has not reached the closing curly brace).
- When you call a method, the method lands on the top of a call stack. That new thing that’s actually pushed onto the stack is the stack frame.
- The method on the top of the stack is always the currently executing method.
- If the local variable is a reference to an object, only the variable (the reference/remote control) goes on the stack.
- A constructor has the code that runs when you instantiate an object. In other words, the code that runs when you say new on a class type. Every class you write has a constructor, even if you don't write it yourself.
- The only way to invoke a constructor is with the keyword new followed by the class name. The JVM finds that class and invokes the constructor in that class.
- The key feature of a constructor is that it runs before the object can be assigned to a reference.
- Instance variables do have a default value. 0 or 0.0 for numeric primitives, false for booleans, and null for references.
- Q: Why do you need to write a constructor if the compiler writes one for you?
    - A: You need to write your own constructor if you require code to initialize your object and prepare it for use. This is particularly necessary when dependencies on user input exist, hindering the completion of object preparation. Additionally, writing a constructor may be necessary due to your superclass constructor, a topic to be discussed shortly.
- Q: How can you tell a constructor from a method? Can you also have a method that's the same name as the class?
    - A: Java allows you to declare a method with the same name as your class, but it doesn't make it a constructor. The crucial distinction lies in the return type—methods must have a return type, whereas constructors cannot. For example:
    - public Duck () { } // Constructor
public void Duck () { } // Method (Not Recommeded) 
        - Although the compiler permits such methods, it is discouraged due to violating naming conventions and causing confusion.
- Q: Are constructors inherited? If you don't provide a constructor but your superclass does, do you get the superclass constructor instead of the default?
    - A: No, constructors are not inherited. The absence of a constructor in a subclass does not result in acquiring the superclass constructor by default. This concept will be explored further in subsequent pages.
- If you have more than one constructor in a class, it means you have overloaded constructors.
- If you write a constructor that takes arguments and you still want a no-arg constructor, you'll have to build the no-arg constructor yourself!
- Q: Do constructors have to be public?
    - A: No. Constructors can be public, protected, private, or default (which means no access modifier at all)
- All the constructors in an object's inheritance tree must run when you make a new object.
- Saying new is a Big Deal. It starts the whole constructor chain reaction.
- A call to super() in your constructor puts the superclass constructor on the top of the Stack.
- The superclass parts of an object have to be fully formed (completely built) before the subclass parts can be constructed.
- The call to super() must be the first statement in each constructor!*(There's an exception).
    - Every constructor can have a call to super() or this(), but never both!
- A local variable lives only within the method that declared the variable.
- An instance variable lives as long as the object does. If the object is still alive, SO are its instance variables.
- The difference between life and scope for local variables: 
    - Life - A local variable is alive as long as its Stack frame is on the Stack. In other words, until the method completes.
    - Scope - A local variable is in scope only within the method in which the variable was declared. When its own method calls another, the variable is alive, but not in scope until its method resumes. You can use a variable only when it is in scope.
- An object's life has no value, no meaning, no point, unless somebody has a reference to it. If you can't get to it, you can't ask it to do anything and it's just a big fat waste of bits. But if an object is unreachable, the Garbage Collector will figure that out. Sooner or later, that object's goin' down.
- An object becomes eligible for GC when its last live reference disappears.
- If you use the dot operator on a null reference, you’ll get a NullPointerException at runtime.

### Chapter 09: Summary
- Java has two areas of memory we care about: the Stack and the Heap.
- Instance variables are variables declared inside a class but outside any method.
- Local variables are variables declared inside a method or method parameter.
- All local variables live on the stack, in the frame corresponding to the method where the variables are declared.
- Object reference variables work just like primi- tive variables--if the reference is declared as a local 4 variable, it goes on the stack.
- All objects live in the heap, regardless of whether the reference is a local or instance variable.
- Instance variables live within the object they belong to, on the Heap.
- If the instance variable is a reference to an object, both the reference and the object it refers to are on the Heap. A constructor is the code that runs when you say new on a class type.
- A constructor must have the same name as the class, and must not have a return type.
- You can use a constructor to initialize the state (i.e., the instance variables) of the object being constructed.
- If you don't put a constructor in your class, the compiler will put in a default constructor.
- The default constructor is always a no-arg constructor. If you put a constructor -any constructor-in your class, the compiler will not build the default constructor.
- If you want a no-arg constructor and you've already put in a constructor with arguments, you'll have to build the no-arg constructor yourself.
- Always provide a no-arg constructor if you can, to make it easy for programmers to make a working object. Supply default values.
- Overloaded constructors means you have more than one constructor in your class.
- Overloaded constructors must have different argument lists.
- You cannot have two constructors with the same argument lists. An argument list includes the order and type of arguments.
- Instance variables are assigned a default value, even when you don't explicitly assign one. The default values are 0/0.0/false for primitives, and null for references.